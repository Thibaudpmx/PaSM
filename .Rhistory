timesaved <- (nVP0s - nVPs) * as.double(taddvp) / 200000
nextsteptype <- "zoom"
if(tloop < 2 * timesaved ) nextsteptype <- "all"
# nVPs * as.double(taddvp) / 200000
#   as.double(tloop)
newname <- paste0(c(nextstep$Name, nextstep$todo), collapse = "_")
self$algo2list[[newname]] <- tempVP
self$algo2list$tree  <- self$algo2list$tree %>%
add_row(Name = newname, size =  sizetemp, todo = 1, before = nVP0s, after = nVPs, ratio = nVPs/nVP0s,
time = difftime(Sys.time(), t0, units = "s"), what = nextsteptype
)
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] <- self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] + 1
if(self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] > self$algo2list$tree$size[self$algo2list$tree$Name == nextstep$Name]){
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name]  <- 0
}
nextstep <-  self$algo2list[["tree"]] %>%
filter(todo != 0 ) %>%
filter(what == "all") %>%
filter(!is.na(todo)) %>%
slice(1)
saveRDS(self, "D:/these/Second_project/QSP/modeling_work/VT_simeoni/algo2.RDS")
#
# nextstep <- self$algo2list[["tree"]] %>%
#   filter(Name == newname)
# self$plot_2D(k2, lambda0)
# print("a")
}
}
t0 <- Sys.time()
todo <- nextstep$todo
print(nextstep)
maybe <-  self$algo2list[[nextstep$Name]]
blocs <- maybe[namesparam] %>%
rowid_to_column("id") %>%
gather("key", "value", -id) %>%
mutate(param = gsub("(min$)|(max$)", "", key)) %>%
mutate(a = map2_chr(param, key, ~ gsub(.x, "", .y))) %>%
select(-key) %>%
spread(a, value) %>%
rename(from = min, to = max) %>%
left_join(domain %>% distinct(param, digits), by = "param")
if(nextstep$Name !="first") maybe <- maybe$algo2list[[1]]
blocs <- maybe[namesparam] %>%
rowid_to_column("id") %>%
gather("key", "value", -id) %>%
mutate(param = gsub("(min$)|(max$)", "", key)) %>%
mutate(a = map2_chr(param, key, ~ gsub(.x, "", .y))) %>%
select(-key) %>%
spread(a, value) %>%
rename(from = min, to = max) %>%
left_join(domain %>% distinct(param, digits), by = "param")
blocs
blocs %>%
mutate(sampl = pmap(list(from, to, digits), function(from, to, digits){
# from = 0; to = 3; digits = 4
seq(from, to, 10^(-digits) )  %>% unique()
})) -> VPsparam
# Cross parameter (per bloc) and add fixed values
newVPs <- VPsparam %>%
group_split(id) %>%
map( function(x){
temp <- invoke(.fn = crossing, x$sampl )
names(temp) <- x$param
temp
}) %>%
bind_rows() %>%
add_column(DFfix)
newVPs
newVPs <- newVPs %>% distinct()
newVPs
newVPs <- newVPs %>% distinct()
newVPs <-   newVPs %>%
rowid_to_column("group") %>%
mutate(group = floor(group / 400000) + 1)
tempVP <- self$clone(deep = T)
tempVP$filters_neg_above <- tibble()
tempVP$filters_neg_below <- tibble()
tempVP$algo2list  <- list()
newVPs$group %>% unique()
16E6/400
16E6/400000
12 * 40
12 * 40/ 60
# Now the deep dive
while( nrow(nextstep) == 1){
t0 <- Sys.time()
todo <- nextstep$todo
print(nextstep)
maybe <-  self$algo2list[[nextstep$Name]]
if(nextstep$Name !="first") maybe <- maybe$algo2list[[1]]
if(nextstep$what == "all"){
# Compute all patient
blocs <- maybe[namesparam] %>%
rowid_to_column("id") %>%
gather("key", "value", -id) %>%
mutate(param = gsub("(min$)|(max$)", "", key)) %>%
mutate(a = map2_chr(param, key, ~ gsub(.x, "", .y))) %>%
select(-key) %>%
spread(a, value) %>%
rename(from = min, to = max) %>%
left_join(domain %>% distinct(param, digits), by = "param")
blocs %>%
mutate(sampl = pmap(list(from, to, digits), function(from, to, digits){
# from = 0; to = 3; digits = 4
seq(from, to, 10^(-digits) )  %>% unique()
})) -> VPsparam
# VPsparam
# Cross parameter (per bloc) and add fixed values
newVPs <- VPsparam %>%
group_split(id) %>%
map( function(x){
temp <- invoke(.fn = crossing, x$sampl )
names(temp) <- x$param
temp
}) %>%
bind_rows() %>%
add_column(DFfix)
newVPs <- newVPs %>% distinct()
newVPs <-   newVPs %>%
rowid_to_column("group") %>%
mutate(group = floor(group / 400000) + 1)
tempVP <- self$clone(deep = T)
tempVP$filters_neg_above <- tibble()
tempVP$filters_neg_below <- tibble()
tempVP$algo2list  <- list()
for(a in newVPs$group %>% unique()){
print(paste0(a, "/", length(newVPs$group %>% unique())))
newVPs2 <- newVPs %>%
filter(group == a)
tempVP$add_VP(newVPs2)
#
}
tempVP$n_filter_reduc()
newname <- paste0(nextstep$Name,"_final")
self$algo2list[[newname]] <- tempVP
self$algo2list$tree  <- self$algo2list$tree %>%
add_row(Name = newname, size =  0, todo = 0, before = nrow(newVPs), after = 0, ratio = 0, what = "Done",
difftime(Sys.time(), t0, units = "s")
)
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] <- 0
saveRDS(self, "D:/these/Second_project/QSP/modeling_work/VT_simeoni/algo2.RDS")
nextstep <-  self$algo2list[["tree"]] %>%
filter(todo != 0 ) %>%
filter(what == "all") %>%
filter(!is.na(todo)) %>%
slice(1)
# nextstep <-  self$algo2list[["tree"]] %>%
#   filter(todo != 0 ) %>%
#   # filter(Name == "first") %>%
#   filter(!is.na(todo)) %>%
#   slice(1)
#
# next
}else{
maybe <-  maybe %>%
# self$algo2list[[nextstep$Name]]
filter(blocsPool == todo) %>%
select(-blocsPool)
nVP0s <- ndomain2(maybe)
blocs <- maybe[namesparam] %>%
rowid_to_column("id") %>%
gather("key", "value", -id) %>%
mutate(param = gsub("(min$)|(max$)", "", key)) %>%
mutate(a = map2_chr(param, key, ~ gsub(.x, "", .y))) %>%
select(-key) %>%
spread(a, value) %>%
rename(from = min, to = max) %>%
left_join(domain %>% distinct(param, digits), by = "param")
nperparam <- ceiling((200000/length(unique(blocs$id)))^(1/nrow(domain)))
blocs %>%
mutate(sampl = pmap(list(from, to, digits), function(from, to, digits){
# from = 0; to = 3; digits = 4
seq(from, to, (to-from)/(nperparam-1)) %>% round(digits) %>% unique()
})) -> VPsparam
# Cross parameter (per bloc) and add fixed values
newVPs <- VPsparam %>%
group_split(id) %>%
map( function(x){
temp <- invoke(.fn = crossing, x$sampl )
names(temp) <- x$param
temp
}) %>%
bind_rows() %>%
add_column(DFfix)
tempVP <- self$clone(deep = T)
tempVP$filters_neg_above <- tibble()
tempVP$filters_neg_below <- tibble()
tempVP$algo2list  <- list()
#
# if(nrow(self$poolVP)>0 ){
#
# newVPs <- newVPs %>%
#   left_join(self$poolVP %>% select(!!!parse_exprs(names(newVPs)),  id)) %>%
#   filter(is.na(id)) %>%
#   select(-id)
# }
#
# if(! firstbloc) newVPs <- newVPs %>%
#   left_join(prevVPs %>% mutate(test = 1)) %>%
#   filter(is.na(test)) %>%
#   select(-test)
#
# prevVPs <-newVPs
# newVPs <- invoke(.fn = crossing, .args = VPsparam)%>%
#   add_column(DFfix)
# Compute the new VPs
tempVP$add_VP(newVPs, keepRedFiltaftDis = T, reducefilteratend = T)
# self$n_filter_reduc()
# Compute zone_maybe
sizetemp <- NA
try({
tempVP$compute_zone_maybe()
# Which become the new blocs
# tempVP$zone_maybe
zone_maybe <- tempVP$zone_maybe
zone_maybe <- reduce_maybe2(zone_maybe)
tempVP$algo2list[["blocs"]] <- zone_maybe %>%
rowid_to_column("blocsPool") %>%
mutate(blocsPool = floor(blocsPool/gatherblocsPool) + 1)
sizetemp <- max(tempVP$algo2list[["blocs"]]$blocsPool)
# ndomain2(tempVP$zone_maybe)
})
# maybe
# tempVP$zone_maybe
nVPs <- ndomain2(zone_maybe)
tloop <- difftime(Sys.time(), t0, units = "s")
# Deactivate zoom system if needed
timesaved <- (nVP0s - nVPs) * as.double(taddvp) / 200000
nextsteptype <- "zoom"
if(tloop < 2 * timesaved ) nextsteptype <- "all"
# nVPs * as.double(taddvp) / 200000
#   as.double(tloop)
newname <- paste0(c(nextstep$Name, nextstep$todo), collapse = "_")
self$algo2list[[newname]] <- tempVP
self$algo2list$tree  <- self$algo2list$tree %>%
add_row(Name = newname, size =  sizetemp, todo = 1, before = nVP0s, after = nVPs, ratio = nVPs/nVP0s,
time = difftime(Sys.time(), t0, units = "s"), what = nextsteptype
)
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] <- self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] + 1
if(self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] > self$algo2list$tree$size[self$algo2list$tree$Name == nextstep$Name]){
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name]  <- 0
}
nextstep <-  self$algo2list[["tree"]] %>%
filter(todo != 0 ) %>%
filter(what == "all") %>%
filter(!is.na(todo)) %>%
slice(1)
saveRDS(self, "D:/these/Second_project/QSP/modeling_work/VT_simeoni/algo2.RDS")
#
# nextstep <- self$algo2list[["tree"]] %>%
#   filter(Name == newname)
# self$plot_2D(k2, lambda0)
# print("a")
}
}
tempVP
newVPs$group %>% unique()
tempVP <- self$clone(deep = T)
tempVP$filters_neg_above <- tibble()
tempVP$filters_neg_below <- tibble()
tempVP$algo2list  <- list()
for(a in newVPs$group %>% unique()){
print(paste0(a, "/", length(newVPs$group %>% unique())))
newVPs2 <- newVPs %>%
filter(group == a)
tempVP$add_VP(newVPs2)
#
}
tempVP
newname <- paste0(nextstep$Name,"_final")
self$algo2list[[newname]] <- tempVP
self$algo2list$tree  <- self$algo2list$tree %>%
add_row(Name = newname, size =  0, todo = 0, before = nrow(newVPs), after = 0, ratio = 0, what = "Done",
difftime(Sys.time(), t0, units = "s")
)
self$algo2list$tree
self$algo2list$tree  <- self$algo2list$tree %>%
add_row(Name = newname, size =  0, todo = 0, before = nrow(newVPs), after = 0, ratio = 0, what = "Done",
time =   difftime(Sys.time(), t0, units = "s")
)
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] <- 0
saveRDS(self, "D:/these/Second_project/QSP/modeling_work/VT_simeoni/algo2.RDS")
nextstep <-  self$algo2list[["tree"]] %>%
filter(todo != 0 ) %>%
filter(what == "all") %>%
filter(!is.na(todo)) %>%
slice(1)
nextstep
# Now the deep dive
while( nrow(nextstep) == 1){
t0 <- Sys.time()
todo <- nextstep$todo
print(nextstep)
maybe <-  self$algo2list[[nextstep$Name]]
if(nextstep$Name !="first") maybe <- maybe$algo2list[[1]]
if(nextstep$what == "all"){
# Compute all patient
blocs <- maybe[namesparam] %>%
rowid_to_column("id") %>%
gather("key", "value", -id) %>%
mutate(param = gsub("(min$)|(max$)", "", key)) %>%
mutate(a = map2_chr(param, key, ~ gsub(.x, "", .y))) %>%
select(-key) %>%
spread(a, value) %>%
rename(from = min, to = max) %>%
left_join(domain %>% distinct(param, digits), by = "param")
blocs %>%
mutate(sampl = pmap(list(from, to, digits), function(from, to, digits){
# from = 0; to = 3; digits = 4
seq(from, to, 10^(-digits) )  %>% unique()
})) -> VPsparam
# VPsparam
# Cross parameter (per bloc) and add fixed values
newVPs <- VPsparam %>%
group_split(id) %>%
map( function(x){
temp <- invoke(.fn = crossing, x$sampl )
names(temp) <- x$param
temp
}) %>%
bind_rows() %>%
add_column(DFfix)
newVPs <- newVPs %>% distinct()
newVPs <-   newVPs %>%
rowid_to_column("group") %>%
mutate(group = floor(group / 400000) + 1)
tempVP <- self$clone(deep = T)
tempVP$filters_neg_above <- tibble()
tempVP$filters_neg_below <- tibble()
tempVP$algo2list  <- list()
for(a in newVPs$group %>% unique()){
print(paste0(a, "/", length(newVPs$group %>% unique())))
newVPs2 <- newVPs %>%
filter(group == a)
tempVP$add_VP(newVPs2)
#
}
print(tempVP)
# tempVP$n_filter_reduc()
newname <- paste0(nextstep$Name,"_final")
self$algo2list[[newname]] <- tempVP
self$algo2list$tree  <- self$algo2list$tree %>%
add_row(Name = newname, size =  0, todo = 0, before = nrow(newVPs), after = 0, ratio = 0, what = "Done",
time =   difftime(Sys.time(), t0, units = "s")
)
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] <- 0
saveRDS(self, "D:/these/Second_project/QSP/modeling_work/VT_simeoni/algo2.RDS")
nextstep <-  self$algo2list[["tree"]] %>%
filter(todo != 0 ) %>%
filter(what == "all") %>%
filter(!is.na(todo)) %>%
slice(1)
# nextstep <-  self$algo2list[["tree"]] %>%
#   filter(todo != 0 ) %>%
#   # filter(Name == "first") %>%
#   filter(!is.na(todo)) %>%
#   slice(1)
#
# next
}else{
maybe <-  maybe %>%
# self$algo2list[[nextstep$Name]]
filter(blocsPool == todo) %>%
select(-blocsPool)
nVP0s <- ndomain2(maybe)
blocs <- maybe[namesparam] %>%
rowid_to_column("id") %>%
gather("key", "value", -id) %>%
mutate(param = gsub("(min$)|(max$)", "", key)) %>%
mutate(a = map2_chr(param, key, ~ gsub(.x, "", .y))) %>%
select(-key) %>%
spread(a, value) %>%
rename(from = min, to = max) %>%
left_join(domain %>% distinct(param, digits), by = "param")
nperparam <- ceiling((200000/length(unique(blocs$id)))^(1/nrow(domain)))
blocs %>%
mutate(sampl = pmap(list(from, to, digits), function(from, to, digits){
# from = 0; to = 3; digits = 4
seq(from, to, (to-from)/(nperparam-1)) %>% round(digits) %>% unique()
})) -> VPsparam
# Cross parameter (per bloc) and add fixed values
newVPs <- VPsparam %>%
group_split(id) %>%
map( function(x){
temp <- invoke(.fn = crossing, x$sampl )
names(temp) <- x$param
temp
}) %>%
bind_rows() %>%
add_column(DFfix)
tempVP <- self$clone(deep = T)
tempVP$filters_neg_above <- tibble()
tempVP$filters_neg_below <- tibble()
tempVP$algo2list  <- list()
#
# if(nrow(self$poolVP)>0 ){
#
# newVPs <- newVPs %>%
#   left_join(self$poolVP %>% select(!!!parse_exprs(names(newVPs)),  id)) %>%
#   filter(is.na(id)) %>%
#   select(-id)
# }
#
# if(! firstbloc) newVPs <- newVPs %>%
#   left_join(prevVPs %>% mutate(test = 1)) %>%
#   filter(is.na(test)) %>%
#   select(-test)
#
# prevVPs <-newVPs
# newVPs <- invoke(.fn = crossing, .args = VPsparam)%>%
#   add_column(DFfix)
# Compute the new VPs
tempVP$add_VP(newVPs, keepRedFiltaftDis = T, reducefilteratend = T)
# self$n_filter_reduc()
# Compute zone_maybe
sizetemp <- NA
try({
tempVP$compute_zone_maybe()
# Which become the new blocs
# tempVP$zone_maybe
zone_maybe <- tempVP$zone_maybe
zone_maybe <- reduce_maybe2(zone_maybe)
tempVP$algo2list[["blocs"]] <- zone_maybe %>%
rowid_to_column("blocsPool") %>%
mutate(blocsPool = floor(blocsPool/gatherblocsPool) + 1)
sizetemp <- max(tempVP$algo2list[["blocs"]]$blocsPool)
# ndomain2(tempVP$zone_maybe)
})
# maybe
# tempVP$zone_maybe
nVPs <- ndomain2(zone_maybe)
tloop <- difftime(Sys.time(), t0, units = "s")
# Deactivate zoom system if needed
timesaved <- (nVP0s - nVPs) * as.double(taddvp) / 200000
nextsteptype <- "zoom"
if(tloop < 2 * timesaved ) nextsteptype <- "all"
# nVPs * as.double(taddvp) / 200000
#   as.double(tloop)
newname <- paste0(c(nextstep$Name, nextstep$todo), collapse = "_")
self$algo2list[[newname]] <- tempVP
self$algo2list$tree  <- self$algo2list$tree %>%
add_row(Name = newname, size =  sizetemp, todo = 1, before = nVP0s, after = nVPs, ratio = nVPs/nVP0s,
time = difftime(Sys.time(), t0, units = "s"), what = nextsteptype
)
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] <- self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] + 1
if(self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name] > self$algo2list$tree$size[self$algo2list$tree$Name == nextstep$Name]){
self$algo2list$tree$todo[self$algo2list$tree$Name == nextstep$Name]  <- 0
}
nextstep <-  self$algo2list[["tree"]] %>%
filter(todo != 0 ) %>%
filter(what == "all") %>%
filter(!is.na(todo)) %>%
slice(1)
saveRDS(self, "D:/these/Second_project/QSP/modeling_work/VT_simeoni/algo2.RDS")
#
# nextstep <- self$algo2list[["tree"]] %>%
#   filter(Name == newname)
# self$plot_2D(k2, lambda0)
# print("a")
}
}
self
self$algo2list
self$algo2list$first_5
self$algo2list$first_5$algo2list
temp <-  self$algo2list$first_5$algo2list[[1]]
plotextreme <- function(temp, pool =1){
ids <-
temp %>%
filter(blocsPool %in% pool) %>%
rowid_to_column() %>%
group_split(rowid) %>%
map(~  tibble(k2 = c(.x$k2min,.x$k2max), lambda0 = c(.x$lambda0max,.x$lambda0min),
ke = c(.x$kemax,.x$kemin), Vd = c(.x$Vdmax,.x$Vdmin), lambda1 = c(.x$lambda1max,.x$lambda1min)) %>%
mutate(psi = 20, k1 = 0.5) %>%
mutate(rowid = .x$rowid)
) %>%
bind_rows() %>%
rowid_to_column("id")
proto <- self$protocols$dose50 %>%
mutate(evid = 1) %>%
bind_rows(
self$protocols$dose50 %>%
mutate(evid = 0) %>%
select(-time) %>%
crossing(time = self$times) %>%
mutate(amt = 0)
) %>%
crossing(id = 1:nrow(ids)) %>%
arrange(id, time)
self$model$solve(ids, proto, c(X1 = 50)) %>%
as.tibble() %>%
left_join(ids %>% distinct(id, rowid))
}
temp
plotextreme(temp, pool = 1)
plotextreme(temp, pool = 1) %>%
filter(rowid <20) %>%
ggplot()+
geom_line(aes(time, tumVol, group = id))+
scale_y_log10()+
geom_point(data = self$targets, aes(time, min), col = "red")+
geom_line(data=ref %>% select(-rowid), aes(time, tumVol, group = id), col = "red")+
facet_wrap(~rowid)
plotextreme(temp, pool = 1) %>%
filter(rowid <20) %>%
ggplot()+
geom_line(aes(time, tumVol, group = id))+
scale_y_log10()+
geom_point(data = self$targets, aes(time, min), col = "red")+
# geom_line(data=ref %>% select(-rowid), aes(time, tumVol, group = id), col = "red")+
facet_wrap(~rowid)
