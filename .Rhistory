# Handling death and survival agents, to greatly accelerate the process
all_param <- names(poolVP)
all_param <- all_param[! all_param %in% c("cellid", "rowid",col_to_add)]
line_compar <-   paste0("poolVP$", all_param, " == line$", all_param) %>%
paste0(collapse = " & ")
# poolVPprev <-poolVP
# poolVP <- poolVPprev
poolVPDone <- poolVP %>% slice(0)
maxinfo <- is.na(poolVP[, col_to_add]) %>% sum
above <- double()
below <- double()
nn <- 0
newratio <- is.na(poolVP[, col_to_add]) %>% sum
pb$update(ratio = (maxinfo -newratio )/maxinfo)
if(time_compteur == T){
n_compteur <- n_compteur + 1
poolVP_compteur_new <- poolVP_compteur %>%
slice(1) %>%
mutate(n = n_compteur)
}
# Just compute some stat...
t0 <- Sys.time()
filter_to_use <-  paste0("is.na(", col_to_add,")") %>%
paste0(collapse = "|")
line <- poolVP %>%
filter(!!parse_expr(filter_to_use)) %>%
sample_n(1)
# Now we need to handle the administrations
# by making a temporar copy
protocol  <- protocols[[line$protocol]]
b <- Sys.time()
res <- simulations(ind_param = line, add_events = protocol, returnSim = T);res
# Add the columns for each output
targets_temp <- targets %>%
filter(protocol %in% line$protocol)
# Now let's see if we can extrapolate some other results
# cmtt <- "tumVol"
# cmtt <- "Conc"
cmt_to_update <- unique(targets_temp$cmt)
line %>%
gather("key", "value") %>%
filter(is.na(value)) -> currentlyna
cmt_to_update <- cmt_to_update[cmt_to_update %in% gsub("(_AL$)|(_BU$)", "", currentlyna$key)]
remv <- F
cmt_to_update
cmtt
targets_temp2 <- targets_temp %>%
filter(cmt == cmtt)
# below upper?
res %>%
filter(time %in% targets_temp2$time) %>%
pull(!!parse_expr(cmtt)) -> values
be_up <- if_else(min(values <= targets_temp2$max) == 0, F, T);be_up
ab_low <-  if_else(min(values >= targets_temp2$min) == 0, F, T);ab_low
pa_in_temp <- param_increase[[cmtt]]
pa_in_temp <- pa_in_temp[pa_in_temp %in% all_param]
pa_re_temp <- param_reduce[[cmtt]]
pa_re_temp <- pa_re_temp[pa_re_temp %in% all_param]
pa_ni_temp <- param_no_impact[[cmtt]]
pa_ni_temp <- pa_ni_temp[pa_ni_temp %in% all_param]
# if the line output is death
if(be_up == F){
# create a copy of the line_compar with everything "=="
reject <- paste0("which(", line_compar,")")
# Then replace "==" by "<=" for survival parameters
for(a in pa_in_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " >= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
# Then replace "==" by ">=" for survival parameters
for(a in pa_re_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " <= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
reject <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", reject)
}
reject <- gsub("line\\$protocol",  paste0("\"", line$protocol,"\""), reject)
# Compute the test
reject_eval <- eval(parse_expr(reject))
cellidtorem <- poolVP[reject_eval, "cellid"]$cellid
poolVP <- poolVP %>%
filter(!cellid %in%cellidtorem)
if(saveFilter == T) saveFilterDf <- c(saveFilterDf, reject)
remv <- T
# print(paste0(length(cellidtorem), " cells removed"))
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate(nelim = length(cellidtorem))
if(cmtt == "tumVol") above <- c(above, cellidtorem)
### if the line output is survival
}else if(ab_low == F){
# create a copy of the line_compar with everything "=="
# reject <- paste0(line_compar, "& is.na(poolVP$",    paste0(cmtt, "_AL"),")")
reject <- paste0("which(", line_compar,")")
# Then replace "==" by "<=" for death parameters
for(a in pa_re_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " >= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
# Then replace "==" by ">=" for survival parameters
for(a in pa_in_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " <= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
reject <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", reject)
}
reject <- gsub("line\\$protocol",  paste0("\"", line$protocol,"\""), reject)
# Compute the test
reject_eval <- eval(parse_expr(reject))
cellidtorem <- poolVP[reject_eval, "cellid"]$cellid
poolVP <- poolVP %>%
filter(!cellid %in%cellidtorem)
if(saveFilter == T) saveFilterDf <- c(saveFilterDf, reject)
remv <- T
# print(paste0(length(cellidtorem), " cells removed"))
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate(nelim = length(cellidtorem))
if(cmtt == "tumVol") below <- c(below, cellidtorem)
} # end if-else
# Now update the lines
if(ab_low == TRUE &   paste0(cmtt, "_AL") %in% currentlyna$key){
# create a copy of the line_compar with everything "=="
test_above_lower_lim <- paste0(line_compar, "& is.na(poolVP$",    paste0(cmtt, "_AL"),")")
test_above_lower_lim <- paste0("which(", test_above_lower_lim,")")
for(a in pa_re_temp){
test_above_lower_lim <- gsub(paste0(a, " *=="), paste0(a, " <= "), test_above_lower_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_in_temp){
test_above_lower_lim <- gsub(paste0(a, " *=="), paste0(a, " >= "), test_above_lower_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
test_above_lower_lim  <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", test_above_lower_lim)
}
whichaboveloweer <- eval(parse_expr(test_above_lower_lim))
# poolVP %>%
#   slice(whichaboveloweer) %>%
#   filter(is.na(tumVol_AL)) %>% distinct(protocols)
poolVP[[paste0(cmtt, "_AL")]][whichaboveloweer]  <- TRUE
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate( ninfo = if_else(is.na(poolVP_compteur_new$ninfo),0,poolVP_compteur_new$ninfo)+  length(whichaboveloweer))
# poolVP %>% slice(whichaboveloweer) %>% filter(is.na(tumVol_AL))
} # end if ab_low == T
if(be_up == TRUE &  paste0(cmtt, "_BU") %in% currentlyna$key){
# create a copy of the line_compar with everything "=="
test_below_upper_lim <- paste0(line_compar, "& is.na(poolVP$",    paste0(cmtt, "_BU"),")")
test_below_upper_lim <- paste0("which(", test_below_upper_lim,")")
# Then replace "==" by "<=" for death parameters
for(a in pa_re_temp){
test_below_upper_lim <- gsub(paste0(a, " *=="), paste0(a, " >= "), test_below_upper_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
# Then replace "==" by ">=" for survival parameters
for(a in pa_in_temp){
test_below_upper_lim <- gsub(paste0(a, " *=="), paste0(a, " <= "), test_below_upper_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
test_below_upper_lim  <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", test_below_upper_lim)
}
whichbelowupper <- eval(parse_expr(test_below_upper_lim))
# poolVP %>%
#   slice(whichbelowupper) %>%
#   filter(is.na(tumVol_BU))
poolVP[[paste0(cmtt, "_BU")]][whichbelowupper]  <- TRUE
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate( ninfo = if_else(is.na(poolVP_compteur_new$ninfo),0,poolVP_compteur_new$ninfo)+  length(whichbelowupper))
} # end if be_up == T
# poolVPprev <-poolVP
# poolVP <- poolVPprev
poolVPDone <- poolVP %>% slice(0)
while(is.na(poolVP[, col_to_add]) %>% sum > 0 ){
nn <- 0
# ndone <- nrow(poolVP %>% filter(!is.na(res)))
# print(ndone)
# To gain time, we remove in the poolVP the line already done
# poolVP <- poolVP  %>%slice(-indexdone)
## Allow to have intermediate save, usefull when we let computer run all night
## If the server crashes, we don't loose everything...
# begining while 2----------------------------------------------------------
while(is.na(poolVP[, col_to_add]) %>% sum > 0& nn < saven){
newratio <- is.na(poolVP[, col_to_add]) %>% sum
pb$update(ratio = (maxinfo -newratio )/maxinfo)
if(time_compteur == T){
n_compteur <- n_compteur + 1
poolVP_compteur_new <- poolVP_compteur %>%
slice(1) %>%
mutate(n = n_compteur)
}
# Just compute some stat...
t0 <- Sys.time()
# Sample one rows among the not done yet
# filter =  # which(is.na(poolVP[, col_to_add]) %>% apply(1, sum) != 0 )
filter_to_use <-  paste0("is.na(", col_to_add,")") %>%
paste0(collapse = "|")
line <- poolVP %>%
filter(!!parse_expr(filter_to_use)) %>%
sample_n(1)
# Now we need to handle the administrations
# by making a temporar copy
protocol  <- protocols[[line$protocol]]
# add_events_line$amt[is.na(add_events_line$amt )] <- 0
# And now we can make the simulation and extract the result !
b <- Sys.time()
res <- simulations(ind_param = line, add_events = protocol, returnSim = T);res
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate(computmodel = as.double(difftime(Sys.time(),b, units = "sec")))
# Add the columns for each output
targets_temp <- targets %>%
filter(protocol %in% line$protocol)
# Now let's see if we can extrapolate some other results
# cmtt <- "tumVol"
# cmtt <- "Conc"
cmt_to_update <- unique(targets_temp$cmt)
line %>%
gather("key", "value") %>%
filter(is.na(value)) -> currentlyna
cmt_to_update <- cmt_to_update[cmt_to_update %in% gsub("(_AL$)|(_BU$)", "", currentlyna$key)]
remv <- F
for(cmtt in cmt_to_update){
targets_temp2 <- targets_temp %>%
filter(cmt == cmtt)
# below upper?
res %>%
filter(time %in% targets_temp2$time) %>%
pull(!!parse_expr(cmtt)) -> values
be_up <- if_else(min(values <= targets_temp2$max) == 0, F, T);be_up
ab_low <-  if_else(min(values >= targets_temp2$min) == 0, F, T);ab_low
pa_in_temp <- param_increase[[cmtt]]
pa_in_temp <- pa_in_temp[pa_in_temp %in% all_param]
pa_re_temp <- param_reduce[[cmtt]]
pa_re_temp <- pa_re_temp[pa_re_temp %in% all_param]
pa_ni_temp <- param_no_impact[[cmtt]]
pa_ni_temp <- pa_ni_temp[pa_ni_temp %in% all_param]
# if the line output is death
if(be_up == F){
# create a copy of the line_compar with everything "=="
reject <- paste0("which(", line_compar,")")
# Then replace "==" by "<=" for survival parameters
for(a in pa_in_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " >= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
# Then replace "==" by ">=" for survival parameters
for(a in pa_re_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " <= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
reject <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", reject)
}
reject <- gsub("line\\$protocol",  paste0("\"", line$protocol,"\""), reject)
# Compute the test
reject_eval <- eval(parse_expr(reject))
cellidtorem <- poolVP[reject_eval, "cellid"]$cellid
poolVP <- poolVP %>%
filter(!cellid %in%cellidtorem)
if(saveFilter == T) saveFilterDf <- c(saveFilterDf, reject)
remv <- T
# print(paste0(length(cellidtorem), " cells removed"))
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate(nelim = length(cellidtorem))
if(cmtt == "tumVol") above <- c(above, cellidtorem)
### if the line output is survival
}else if(ab_low == F){
# create a copy of the line_compar with everything "=="
# reject <- paste0(line_compar, "& is.na(poolVP$",    paste0(cmtt, "_AL"),")")
reject <- paste0("which(", line_compar,")")
# Then replace "==" by "<=" for death parameters
for(a in pa_re_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " >= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
# Then replace "==" by ">=" for survival parameters
for(a in pa_in_temp){
reject <- gsub(paste0(a, " *=="), paste0(a, " <= "), reject)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
reject <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", reject)
}
reject <- gsub("line\\$protocol",  paste0("\"", line$protocol,"\""), reject)
# Compute the test
reject_eval <- eval(parse_expr(reject))
cellidtorem <- poolVP[reject_eval, "cellid"]$cellid
poolVP <- poolVP %>%
filter(!cellid %in%cellidtorem)
if(saveFilter == T) saveFilterDf <- c(saveFilterDf, reject)
remv <- T
# print(paste0(length(cellidtorem), " cells removed"))
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate(nelim = length(cellidtorem))
if(cmtt == "tumVol") below <- c(below, cellidtorem)
} # end if-else
# Now update the lines
if(ab_low == TRUE &   paste0(cmtt, "_AL") %in% currentlyna$key){
# create a copy of the line_compar with everything "=="
test_above_lower_lim <- paste0(line_compar, "& is.na(poolVP$",    paste0(cmtt, "_AL"),")")
test_above_lower_lim <- paste0("which(", test_above_lower_lim,")")
for(a in pa_re_temp){
test_above_lower_lim <- gsub(paste0(a, " *=="), paste0(a, " <= "), test_above_lower_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_in_temp){
test_above_lower_lim <- gsub(paste0(a, " *=="), paste0(a, " >= "), test_above_lower_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
test_above_lower_lim  <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", test_above_lower_lim)
}
whichaboveloweer <- eval(parse_expr(test_above_lower_lim))
# poolVP %>%
#   slice(whichaboveloweer) %>%
#   filter(is.na(tumVol_AL)) %>% distinct(protocols)
poolVP[[paste0(cmtt, "_AL")]][whichaboveloweer]  <- TRUE
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate( ninfo = if_else(is.na(poolVP_compteur_new$ninfo),0,poolVP_compteur_new$ninfo)+  length(whichaboveloweer))
# poolVP %>% slice(whichaboveloweer) %>% filter(is.na(tumVol_AL))
} # end if ab_low == T
if(be_up == TRUE &  paste0(cmtt, "_BU") %in% currentlyna$key){
# create a copy of the line_compar with everything "=="
test_below_upper_lim <- paste0(line_compar, "& is.na(poolVP$",    paste0(cmtt, "_BU"),")")
test_below_upper_lim <- paste0("which(", test_below_upper_lim,")")
# Then replace "==" by "<=" for death parameters
for(a in pa_re_temp){
test_below_upper_lim <- gsub(paste0(a, " *=="), paste0(a, " >= "), test_below_upper_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
# Then replace "==" by ">=" for survival parameters
for(a in pa_in_temp){
test_below_upper_lim <- gsub(paste0(a, " *=="), paste0(a, " <= "), test_below_upper_lim)%>%
gsub(pattern = paste0("line\\$", a), replacement = line[[a]])
}
for(a in pa_ni_temp){
test_below_upper_lim  <-
gsub(paste0("&? * poolVP\\$", a, " *== *line\\$",a),"", test_below_upper_lim)
}
whichbelowupper <- eval(parse_expr(test_below_upper_lim))
# poolVP %>%
#   slice(whichbelowupper) %>%
#   filter(is.na(tumVol_BU))
poolVP[[paste0(cmtt, "_BU")]][whichbelowupper]  <- TRUE
if(time_compteur == T) poolVP_compteur_new <- poolVP_compteur_new %>%
mutate( ninfo = if_else(is.na(poolVP_compteur_new$ninfo),0,poolVP_compteur_new$ninfo)+  length(whichbelowupper))
} # end if be_up == T
}# end for each compartment
if(remv == F & saveSimul == T){
siml <- siml %>%
add_row(cellid = line$cellid, protocol = line$protocol, simul = list(res))
}
# if() siml <- tibble(cellid = integer(), protocoles = character(), simul= list())
if(time_compteur == T)  poolVP_compteur <- bind_rows(poolVP_compteur,poolVP_compteur_new %>%
mutate(time = as.double(difftime(Sys.time(), t0, units = "sec"))))
nn <- nn +1
# print(nn)
}# fin while 1
# Just print some stuff
# nnewlines <- sum(!is.na(poolVP$res)) - before
# print( paste0(nnewlines,  " new lines proceeded"))
# print(Sys.time() - t0)
# print(Sys.time() - t00)
print("#####################################################")
indexdone <- which(is.na(poolVP[, col_to_add]) %>% apply(1, sum) == 0 )
poolVPDone <- bind_rows(poolVPDone, poolVP %>% slice(indexdone))
poolVP <- poolVP %>% slice(-indexdone)
above <<- above
below <<- below
## Allow to have intermediate save, usefull when we
# pctdone <- (length(poolVP$rowid[!is.na(poolVP$res)]) +  nrow(poolVPDone)) / ntotal
# print(paste0("Percentage done: ", round(pctdone * 100, 3), "%"))
# nn <- nn +1
# print(nn)
}#fin while 2
toadd
line
line
reject
rm(list=ls())
library(RxODE)
#'  Create poolVP
#' @export
#'
#'
VP_proj_creator <- R6Class("VT",
public = list( model = NULL,
# targets = NULL,
filters_neg = NULL,
filters_ab_lo = NULL,
filters_be_up = NULL,
data = NULL,
parameters_default_values = NULL,# c(psi = 20) # paremeters value to be used by default (NA if you want to force providing value)
initial_cmt_values = NULL, #c(X1 = 50) # initial compartment values. At least one, and every missing cmt name would be set to 0
times = NULL, #seq(0,52, 1)
protocols = NULL,
param_reduce = NULL,
param_increase = NULL,
param_no_impact = NULL,
targets = NULL,
initialize = function(sourcefile= "D:/these/Second_project/QSP/modeling_work/VT_simeoni/1_user_inputs/1_config.r"){
myEnv <- new.env()
source(sourcefile, local=myEnv)
# attach(myEnv, name="sourced_scripts")
self$model <- myEnv$model_RxODE
self$data <- myEnv$data_VT
self$parameters_default_values <- myEnv$parameters_default_values
self$initial_cmt_values <- myEnv$initial_cmt_values
self$times <- myEnv$times
self$protocols <- myEnv$protocols
self$param_reduce <- myEnv$param_reduce
self$param_increase <- myEnv$param_increase
self$param_no_impact <- myEnv$param_no_impact
},
print = function(...) {
cat("Person: \n")
cat("  Name: ", self$times, "\n", sep = "")
cat("  Age: ")
invisible(self)
}
)
)
library(R6)
#'  Create poolVP
#' @export
#'
#'
VP_proj_creator <- R6Class("VT",
public = list( model = NULL,
# targets = NULL,
filters_neg = NULL,
filters_ab_lo = NULL,
filters_be_up = NULL,
data = NULL,
parameters_default_values = NULL,# c(psi = 20) # paremeters value to be used by default (NA if you want to force providing value)
initial_cmt_values = NULL, #c(X1 = 50) # initial compartment values. At least one, and every missing cmt name would be set to 0
times = NULL, #seq(0,52, 1)
protocols = NULL,
param_reduce = NULL,
param_increase = NULL,
param_no_impact = NULL,
targets = NULL,
initialize = function(sourcefile= "D:/these/Second_project/QSP/modeling_work/VT_simeoni/1_user_inputs/1_config.r"){
myEnv <- new.env()
source(sourcefile, local=myEnv)
# attach(myEnv, name="sourced_scripts")
self$model <- myEnv$model_RxODE
self$data <- myEnv$data_VT
self$parameters_default_values <- myEnv$parameters_default_values
self$initial_cmt_values <- myEnv$initial_cmt_values
self$times <- myEnv$times
self$protocols <- myEnv$protocols
self$param_reduce <- myEnv$param_reduce
self$param_increase <- myEnv$param_increase
self$param_no_impact <- myEnv$param_no_impact
},
print = function(...) {
cat("Person: \n")
cat("  Name: ", self$times, "\n", sep = "")
cat("  Age: ")
invisible(self)
}
)
)
#'  Create poolVP
#' @export
#'
#'
VP_proj_creator <- R6Class("VT",
public = list( model = NULL,
# targets = NULL,
filters_neg = NULL,
filters_ab_lo = NULL,
filters_be_up = NULL,
data = NULL,
parameters_default_values = NULL,# c(psi = 20) # paremeters value to be used by default (NA if you want to force providing value)
initial_cmt_values = NULL, #c(X1 = 50) # initial compartment values. At least one, and every missing cmt name would be set to 0
times = NULL, #seq(0,52, 1)
protocols = NULL,
param_reduce = NULL,
param_increase = NULL,
param_no_impact = NULL,
targets = NULL,
initialize = function(sourcefile= "D:/these/Second_project/QSP/modeling_work/VT_simeoni/1_user_inputs/1_config.r"){
myEnv <- new.env()
source(sourcefile, local=myEnv)
# attach(myEnv, name="sourced_scripts")
self$model <- myEnv$model_RxODE
self$data <- myEnv$data_VT
self$parameters_default_values <- myEnv$parameters_default_values
self$initial_cmt_values <- myEnv$initial_cmt_values
self$times <- myEnv$times
self$protocols <- myEnv$protocols
self$param_reduce <- myEnv$param_reduce
self$param_increase <- myEnv$param_increase
self$param_no_impact <- myEnv$param_no_impact
},
print = function(...) {
cat("Person: \n")
cat("  Name: ", self$times, "\n", sep = "")
cat("  Age: ")
invisible(self)
}
)
)
